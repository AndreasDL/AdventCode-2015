package main


import(
	"testing"
)

func Test_clean(t *testing.T){
	cases := []struct{
		input, output string
		first int
	}{
		{"...#..#.#..##......###...###...........", "#..#.#..##......###...###"            , 3},
		{"...#...#....#.....#..#..#..#...........", "#...#....#.....#..#..#..#"            , 3},
		{"...##..##...##....#..#..#..##..........", "##..##...##....#..#..#..##"           , 3},
		{"..#.#...#..#.#....#..#..#...#..........", "#.#...#..#.#....#..#..#...#"          , 2},
		{"...#.#..#...#.#...#..#..##..##.........", "#.#..#...#.#...#..#..##..##"          , 3},

		{"....#...##...#.#..#..#...#...#.........", "#...##...#.#..#..#...#...#"           , 4},
		{"....##.#.#....#...#..##..##..##........", "##.#.#....#...#..##..##..##"          , 4},
		{"...#..###.#...##..#...#...#...#........", "#..###.#...##..#...#...#...#"         , 3},
		{"...#....##.#.#.#..##..##..##..##.......", "#....##.#.#.#..##..##..##..##"        , 3},
		{"...##..#..#####....#...#...#...#.......", "##..#..#####....#...#...#...#"        , 3},

		{"..#.#..#...#.##....##..##..##..##......", "#.#..#...#.##....##..##..##..##"      , 2},
		{"...#...##...#.#...#.#...#...#...#......", "#...##...#.#...#.#...#...#...#"       , 3},
		{"...##.#.#....#.#...#.#..##..##..##.....", "##.#.#....#.#...#.#..##..##..##"      , 3},
		{"..#..###.#....#.#...#....#...#...#.....", "#..###.#....#.#...#....#...#...#"     , 2},
		{"..#....##.#....#.#..##...##..##..##....", "#....##.#....#.#..##...##..##..##"    , 2},

		{"..##..#..#.#....#....#..#.#...#...#....", "##..#..#.#....#....#..#.#...#...#"    , 2},
		{".#.#..#...#.#...##...#...#.#..##..##...", "#.#..#...#.#...##...#...#.#..##..##"  , 1},
		{"..#...##...#.#.#.#...##...#....#...#...", "#...##...#.#.#.#...##...#....#...#"   , 2},
		{"..##.#.#....#####.#.#.#...##...##..##..", "##.#.#....#####.#.#.#...##...##..##"  , 2},
		{".#..###.#..#.#.#######.#.#.#..#.#...#..", "#..###.#..#.#.#######.#.#.#..#.#...#" , 1},
		{".#....##....#####...#######....#.#..##.", "#....##....#####...#######....#.#..##", 1},
	}

	for i, c := range cases {
		actual, pos := clean(c.input, 0)

		if actual != c.output{
			t.Fatalf(
				"at %d => %s should be %s",
				i,
				actual,
				c.output,
			)
		} else if pos != c.first {
			t.Fatalf(
				"at %d => %d should be %d",
				i,
				pos,
				c.first,
			)
		}


	}
}

func Test_next(t *testing.T){

	input := []string{
		"...## => #",
		"..#.. => #",
		".#... => #",
		".#.#. => #",
		".#.## => #",
		".##.. => #",
		".#### => #",
		"#.#.# => #",
		"#.### => #",
		"##.#. => #",
		"##.## => #",
		"###.. => #",
		"###.# => #",
		"####. => #",
	}

	cases := []struct{
		state string
		pos int
	}{
		//"#..#.#..##......###...###",
		{"#...#....#.....#..#..#..#"            ,  0},
		{"##..##...##....#..#..#..##"           ,  0},
		{"#.#...#..#.#....#..#..#...#"          , -1},
		{"#.#..#...#.#...#..#..##..##"          ,  0},
		{"#...##...#.#..#..#...#...#"           ,  1},
		{"##.#.#....#...#..##..##..##"          ,  1},
		{"#..###.#...##..#...#...#...#"         ,  0},
		{"#....##.#.#.#..##..##..##..##"        ,  0},
		{"##..#..#####....#...#...#...#"        ,  0},
		{"#.#..#...#.##....##..##..##..##"      , -1},
		{"#...##...#.#...#.#...#...#...#"       ,  0},
		{"##.#.#....#.#...#.#..##..##..##"      ,  0},
		{"#..###.#....#.#...#....#...#...#"     , -1},
		{"#....##.#....#.#..##...##..##..##"    , -1},
		{"##..#..#.#....#....#..#.#...#...#"    , -1},
		{"#.#..#...#.#...##...#...#.#..##..##"  , -2},
		{"#...##...#.#.#.#...##...#....#...#"   , -1},
		{"##.#.#....#####.#.#.#...##...##..##"  , -1},
		{"#..###.#..#.#.#######.#.#.#..#.#...#" , -2},
		{"#....##....#####...#######....#.#..##", -2},
	}

	//get mappings
	mappings := loadMappings(&input)
	state := "#..#.#..##......###...###"
	pos := 0

	for i, c := range cases {
		
		state, pos = next(mappings, state, pos)
		if state != c.state {
			t.Fatalf("at %d => %s should be %s",
				i,
				state,
				c.state,
			)
		} else if pos != c.pos {
			t.Fatalf("at %d => %d should be %d",
				i,
				pos,
				c.pos,
			)
		}

	}
}

func Test_part1(t *testing.T){
	input := []string{
		"...## => #",
		"..#.. => #",
		".#... => #",
		".#.#. => #",
		".#.## => #",
		".##.. => #",
		".#### => #",
		"#.#.# => #",
		"#.### => #",
		"##.#. => #",
		"##.## => #",
		"###.. => #",
		"###.# => #",
		"####. => #",
	}
	mappings := loadMappings(&input)
	state := "#..#.#..##......###...###"

	res := part1(mappings, state,20)
	if res != 325 {
		t.Fatalf("%d should be %d", res, 325)
	}

}